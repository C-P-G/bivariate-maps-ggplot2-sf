---
title: "Bivariate maps with ggplot2 and sf"
author: "Timo Grossenbacher and Angelo Zehr"
date: "April 18, 2019"
output:
  md_document:
    variant: markdown_phpextra+backtick_code_blocks
    toc: yes
    toc_depth: 3
# output:
#   html_document:
#     code_folding: show
#     df_print: kable
#     toc: yes
#     toc_depth: 4
#     toc_float:
#       collapsed: false
#       smooth_scroll: false
---

```{r, echo=FALSE}
# CONFIG
user_name <- "grssnbchr" # your Git username (only needed if
# you want to deploy to GH pages)
project_name <- "bivariate-maps-ggplot2-sf" # adapt!
package_date <- "2019-03-01" # date of the CRAN snapshot that
# the checkpoint package uses
R_version <- "3.5.3" # R-Version to use
options(Ncpus = 4) # use 4 cores for parallelized installation of packages
if (R_version != paste0(version$major, ".", version$minor)){
  stop("ERROR: specified R version does not match currently used.")
}
```

## Notes

This report was generated on `r Sys.time()`. R version: `r paste0(version$major, ".", version$minor)` on `r version$platform`. For this report, CRAN packages as of `r package_date` were used.

...

### R-Script & data

The preprocessing and analysis of the data was conducted in the [R project for statistical computing](https://www.r-project.org/). The RMarkdown script used to generate this document and all the resulting data can be downloaded [under this link](http://`r user_name`.github.io/`r project_name`/rscript.zip). Through executing `main.Rmd`, the herein described process can be reproduced and this document can be generated. In the course of this, data from the folder `Ã¬nput` will be processed and results will be written to `output`. 

### GitHub

The code for the herein described process can also be freely downloaded from [https://github.com/`r user_name`/`r project_name`](https://github.com/`r user_name`/`r project_name`). 


### License

...

### Data description of output files

#### `abc.csv` (Example)

| Attribute | Type | Description |
|-------|------|-----------------------------------------------------------------------------|
| a | Numeric | ... |
| b | Numeric | ... |
| c | Numeric |  ... |

### `xyz.csv` 

...

## Preparations

```{r, echo=FALSE}
detach_all_packages <- function() {
  basic_packages_blank <-  c("stats",
                             "graphics",
                             "grDevices",
                             "utils",
                             "datasets",
                             "methods",
                             "base")
  basic_packages <- paste("package:", basic_packages_blank, sep = "")

  package_list <- search()[
    ifelse(unlist(gregexpr("package:", search())) == 1, TRUE, FALSE)]

  package_list <- setdiff(package_list, basic_packages)

  if (length(package_list) > 0)  for (package in package_list) {
    detach(package, character.only = TRUE, unload = TRUE)
    print(paste("package ", package, " detached", sep = ""))
  }
}

detach_all_packages()

# this allows multiple persons to use the same RMarkdown
# without adjusting the working directory by themselves all the time
source("scripts/csf.R")
path_to_wd <- csf() # if this - for some reason - does not work,
# replace with a hardcoded path, like so: "~/projects/rddj-template/analysis/"
if ( is.null(path_to_wd) | !dir.exists(path_to_wd)) {
  print("WARNING: No working directory specified for current user")
} else {
  setwd(path_to_wd)
}

# suppress scientific notation
options(scipen = 999)

# unload global rstudioapi and knitr again to avoid conflicts with checkpoint
# this is only necessary if executed within RStudio
# outside of RStudio, namely in the knit.sh script, this causes RMarkdown
# rendering to fail, thus should not be executed there
if (Sys.getenv("RSTUDIO") == "1"){
  detach_all_packages()
}
```


### Define packages

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# from https://mran.revolutionanalytics.com/web/packages/checkpoint/vignettes/using-checkpoint-with-knitr.html
# if you don't need a package, remove it from here (commenting is probably not sufficient)
# tidyverse: see https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/
cat("
library(rstudioapi)
library(tidyverse) # ggplot2, dplyr, tidyr, readr, purrr, tibble
library(magrittr) # pipes
library(lintr) # code linting
library(sf) # spatial data handling
library(raster) # raster handling (needed for relief)
library(rmarkdown)",
file = "manifest.R")
```

### Install packages

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# if checkpoint is not yet installed, install it (for people using this
# system for the first time)
if (!require(checkpoint)) {
  if (!require(devtools)) {
    install.packages("devtools", repos = "http://cran.us.r-project.org")
    require(devtools)
  }
  devtools::install_github("RevolutionAnalytics/checkpoint",
                           ref = "v0.3.2", # could be adapted later,
                           # as of now (beginning of July 2017
                           # this is the current release on CRAN)
                           repos = "http://cran.us.r-project.org")
  require(checkpoint)
}
# nolint start
if (!dir.exists("~/.checkpoint")) {
  dir.create("~/.checkpoint")
}
# nolint end
# install packages for the specified CRAN snapshot date
checkpoint(snapshotDate = package_date,
           project = path_to_wd,
           verbose = T,
           scanForPackages = T,
           use.knitr = F,
           R.version = R_version)
rm(package_date)
```


### Load packages

```{r, echo=TRUE, message=FALSE, warning=FALSE}
source("manifest.R")
unlink("manifest.R")
sessionInfo()
```

## Read data

```{r read data, echo=TRUE, message=FALSE, warning=FALSE}

data <- read_csv("input/data.csv")

``` 

## Read Geodata

On Mac OS you might run into the error message "Cannot create RasterLayer object from this file; perhaps you need to
install rgdal first" on line 207. In that case, install gdal and geos from <http://www.kyngchaos.com/software/frameworks/>.

```{r read in shape files}

# read municipality borders from 2015 (2324 municipalities)
municipality_geo <- read_sf("input/g2g15.shp")

# read cantonal borders
canton_geo <- read_sf("input/g2k15.shp")

# read country borders
country_geo <- read_sf("input/g2l15.shp")

# read lakes
lake_geo <- read_sf("input/g2s15.shp")

# read productive area
productive_area <- read_sf("input/productive_areas.shp")

# read in raster of relief (hillshading)
relief <- raster("input/02-relief-georef.tif") %>%
  # hide hillshading outside of switzerland by masking with country borders
  mask(country_geo) %>%
  as("SpatialPixelsDataFrame") %>%
  as.data.frame() %>%
  rename(value = `X02.relief.georef`)

# clean up
rm(country_geo)

```

## Join Geodata with data

```{r join data into shapefiles}

# join into spatial data frame
municipality_geo %<>%
  left_join(data, by = c("GMDNR" = "bfs_id"))

# make new shape by intersecting municipality geodata with productive areas
# this is needed so the hillshading is visible on unproductive areas
municipality_prod_geo <-
  st_intersection(
    municipality_geo,
    productive_area
  )

# clean up
rm(municipality_geo)

```


```{r define clean theme without axis, grid lines and margins}

theme_clean <- function(...) {
  theme_void() +
  theme(
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.minor = element_blank(),
    # due to a bug in ggplot the panel grid major in combination
    # with geom_sf does not work with element blank
    # read more: https://github.com/tidyverse/ggplot2/issues/2071
    panel.grid.major = element_line(colour = "transparent"),
    panel.background = element_blank(),
    plot.background = element_blank(),
    plot.margin = grid::unit(c(0, 0, 0, 0), "mm")
  )
}

```

First, let's create a standard (univariate) thematic map based on the gini alone.

```{r thematic univariate map}

ggplot(
  municipality_prod_geo,
  aes(fill = gini)
) +
  # first: draw the relief
  geom_raster(
    data = relief,
    inherit.aes = FALSE,
    aes(
      x = x,
      y = y,
      alpha = value
    )
  ) +
  # use the "alpha hack"
  scale_alpha(name = "", range = c(0.6, 0), guide = F)  +
  # use thin white stroke for municipalities
  geom_sf(
    color = "white",
    size = 0.1
  ) +
  # use thicker white stroke for cantons
  geom_sf(
    data = canton_geo,
    inherit.aes = FALSE,
    fill = "transparent",
    color = "white",
    size = 0.5
  ) +
  # draw lakes in light blue
  geom_sf(
    data = lake_geo,
    inherit.aes = FALSE,
    fill = "#D6F1FF",
    color = "transparent"
  ) +
  theme_clean()

```

### Create the bivariate color scale

[Joshua Stevens](http://www.joshuastevens.net/cartography/make-a-bivariate-choropleth-map/) describes very well how to create the color codes for a sequential bivariate color schemes. Using Sketch we combined four rectangles with fill blue (#1E8CE3) and red (#C91024) each with four different opacities (20%, 40%, 60%, 80%) and blend mode multiply. Which resulted in the hex codes you see below.

```{r prepare bivariate color scale with pretty breaks}

# create 4 buckets for gini
quantiles_gini <- quantile(
  data$gini,
  probs = seq(0, 1, length.out = 4)
)

knitr::kable(
  quantiles_gini
)

# create 4 buckets for mean income
quantiles_mean <- quantile(
  data$mean,
  probs = seq(0, 1, length.out = 4)
)

knitr::kable(
  quantiles_mean
)

# based on the values above, we manually define the breaks in a more human
# readable way by rounding
pretty_breaks_gini <- c(0, 0.4, 0.45, 1)
pretty_breaks_mean <- c(0, 35000, 40000, 1000000)

# create color scale that encodes two variables
# red for gini and blue for mean income
bivariate_color_scale <- tibble(
  "3 - 3" = "#3F2949",
  "2 - 3" = "#435786",
  "1 - 3" = "#4885C1",
  "3 - 2" = "#77324C",
  "2 - 2" = "#806A8A",
  "1 - 2" = "#89A1C8",
  "3 - 1" = "#AE3A4E",
  "2 - 1" = "#BC7C8F",
  "1 - 1" = "#CABED0"
) %>%
  gather("group", "fill")

```


### Join color codes into geodata

```{r define which group each data entry belongs to}

# cut into groups defined above and join fill
municipality_prod_geo %<>%
  mutate(
    gini_quantiles = cut(
      gini,
      # you can also use the quantiles with unrounded values: quantiles_gini
      breaks = pretty_breaks_gini,
      include.lowest = TRUE
    ),
    mean_quantiles = cut(
      mean,
      # you can also use the quantiles with unrounded values: quantiles_mean
      breaks = pretty_breaks_mean,
      include.lowest = TRUE
    ),
    # by pasting the factores together as numbers we match the groups defined
    # in the tibble bivariate_color_scale
    group = paste(
      as.numeric(gini_quantiles), "-",
      as.numeric(mean_quantiles)
    )
  ) %>%
  left_join(bivariate_color_scale, by = "group")

```

### Draw bivariate thematic map

```{r}

ggplot(
  municipality_prod_geo,
  aes(
    fill = fill
  )
) +
  # first: draw the relief
  geom_raster(
    data = relief,
    inherit.aes = FALSE,
    aes(
      x = x,
      y = y,
      alpha = value
    )
  ) +
  # use the "alpha hack"
  scale_alpha(name = "", range = c(0.6, 0), guide = F)  +
  # use thin white stroke for municipalities
  geom_sf(
    color = "white",
    size = 0.1
  ) +
  # as the sf object municipality_prod_geo has a colum with name fill that
  # contains the hex code for each municipality, we can use scale_fill_identity
  scale_fill_identity() +
  # use thicker white stroke for cantons
  geom_sf(
    data = canton_geo,
    inherit.aes = FALSE,
    fill = "transparent",
    color = "white",
    size = 0.5
  ) +
  # draw lakes in light blue
  geom_sf(
    data = lake_geo,
    inherit.aes = FALSE,
    fill = "#D6F1FF",
    color = "transparent"
  ) +
  theme_clean()

```


## Linting

The code in this RMarkdown is listed with the [lintr package](https://github.com/jimhester/lintr), which is based on the  [tidyverse style guide](http://style.tidyverse.org/). 

```{r echo=TRUE, message=FALSE, warning=FALSE}
lintr::lint("index.Rmd")
```
